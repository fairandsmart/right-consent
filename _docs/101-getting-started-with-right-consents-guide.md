---
title: Getting started with Right Consents
permalink: /docs/getting-started-guide/
excerpt: "Instructions for starting using and integrating Right Consents in existing applications"
header:
  og_image: /assets/images/gettingstarted-overview.jpg
toc: true
menu: true
---

Learn how to start using Right Consents **backoffice** and **API** to define, collect and query consents using the API via cURL:

- Understand the different **stages** of consent collection in Right Consents
- Discover the backoffice and define your first **consent model elements**
- Use the backoffice assembly tool to try different **consent form layouts**
- Understand the **API basic concepts** and resources
- Use **cURL** to make basic API calls for a simple consent collection scenario


## Prerequisites

To complete this guide you will need:

- Roughly 45 minutes
- Git
- Docker
- Right Consents running
- cURL


## Overview

In this guide, you will discover the different stages that are covered by Right Consents in consent management: the definition of a library of consent elements, the designing of multiple consent collection forms, and their integration into existing applications or websites.

{% include figure image_path="/assets/images/gettingstarted-overview.jpg" alt="Getting Started with Right Consents - Overview Schema" %}

This guide also covers some basic aspects of the API and some basic calls that can to be done by any external application.


## The different stages of consent collection

<!-- TODO: remanier ce bloc -->

Consent collection is a more or less complex operation in the fact that it is either a legal part of a data processing but also a software piece that captures user choice at a specific time and holds that data for a relative long time in a standard way. The information generated by that software piece often need to be accessed or disseminated to third part software as user choices could have an impact on many pieces of an information system.

### Stage one: define

The **first stage** is mainly handled by the data controller themselves or by the data protection officer (DPO) and is mainly an **administrative task**.

This stage aims to **define all the elements** which will take part in the consent collection process. Those elements are purely declarative but they do have a specific structure and will be stored with the consent itself for a _long_ time.

Right Consents helps **defining, managing and preserving** processing declarations but also of other types of information, such as terms of service, preferences, or legal information. Like a CMS, Right Consents handles consent elements **full lifecycle** to ensure their **legal validity** by providing **auditing** and **versionning** as well as generating **digital proofs** of the produced content.

The defined elements will be accessible through the API for the next stage or other dissemination goals (i.e. processing registry).

### Stage two: design

The **second stage** consists in assembling elements into a specific layout that fits with the final integration goal.

For example, terms of service will be collected at the launch of an application or while signing up, whereas some processing consents could be collected only when a specific service is requested. Other processing consents could be collected directly in a website or only in a mobile application.

Right Consents uses the notion of **Consent Context** which holds all the necessary information for an application that handles user consent needs. The Right Consents **backoffice** includes a **graphical tool** to design Consent Contexts.

At the end, you can extract the generated JSON configuration to **integrate** your consent form in any **external application**.

### Stage three: integrate

The **last stage** is handled by a **developer** and consists in using Consent Contexts for integration into the target application.

As Consent Context also contains specific runtime information like the subject ID, the integration needs to be dynamic to match the target context. The Consent Context will then be pushed to the API to declare a new **Consent Transaction** that will act as a consent collection workflow.

The Consent Transaction will also be an **unique entry point** that will live during all the consent preservation time, allowing users to retrieve information about their consent even years later. The integration may require querying end-user choices at some points of the desired user experience.

Once the transaction has been committed, two types of specific pieces of information are generated: **Consent Records** and a **Consent Receipt**.


## Define consent collection elements

### Create an information element

Go to the backoffice application at local URL [http://localhost:4286](http://localhost:4286) (credentials: demo@demo.com / demo42) and **create an information model** by going into the dedicated section (_Menu > Configuration > Information_).
Choose a relevant name and description for that model (only for internal management), for example:
- **Name**: Legal information
- **Description**: A demo of legal information

Then you can **populate** the model **data content**. One single model can have multiple versions of data content, for example:
- **Title**: Demo consent form
- **Header Content**: The Cheesecake Factory Incorporated and its parents, subsidiaries, and affiliated entities (“The Cheesecake Factory,” “the Company,” “we”, “us” or “our”) respect your privacy and we are committed to protecting it through our compliance with our privacy policy (“Privacy Policy”).
- **Footer Content**: Thanks for your trust!
- **Data controller**:
  - **Company**: The Cheesecake Factory
  - **Address**: 26901 Malibu Hills Road, Calabasas Hills, CA 91301
  - **Email**: privacyofficer@thecheesecakefactory.com
  - **Phone Number**: 18664582951
- **Privacy Policy URL**: https://www.thecheesecakefactory.com/corporate-information/privacy-policy

<i class="fa fa-info-circle"></i> For specific documentation about information content, please read the [dedicated guide]({% link _docs/200-consent-elements-doc.md %}).
{: .notice--info}

You are now ready to **publish** that version of the information model by clicking on the **'Save Draft'** button and then on the **'Activate'** button (_don't forget that button!_).

By activating the version, you will be able to use it for collecting consent. As soon as a consent is collected using that version of the information model, you will no longer be able to delete it, only to archive it.

Information about the model lifecycle is visible at the top of the right panel. You may notice that version 1.0 is active and that a unique serial number has been allocated to that particular version.

If you modify on that model, you will have to activate the next version and a popup will ask you for a **major** or **minor** release evolution. A major one will result in all consents collected with that information to be flagged as stale, whereas a minor one will be compatible with already collected consent. All subsequently generated consent transactions will use the newest **active** model version.

### Create a processing element

All model types follow the same lifecycle as the information type described above, only the model data content varies. In order to create a basic form, you will need to create a model for processing description.

In the backoffice application, **create a processing model** (in the same section as before: _Menu > Configuration > Processing_) with a relevant name and description, for example:
- **Name**: Marketing Communication
- **Description**: Demo Marketing Communication

Then you can populate the data content, for example:
- **Title**: Contact Marketing
- **Processed data**: Your contact information (name, surname, email and phone number)
- **Purpose**: We will contact you through your favorite channel (email, sms or phone) to offer discount codes for our newest products.
- **Data retention period**: We will keep your contact information for 2 years

<i class="fa fa-info-circle"></i> For specific documentation about processing content, please read the [dedicated guide]({% link _docs/200-consent-elements-doc.md %}).
{: .notice--info}

Publish the model version by clicking on the 'Save Draft' button and then on the 'Activate' button (_seriously, don't forget that button!_).


## Design a collection form

### Use the backoffice to assemble elements

In the backoffice application, create a consent form design by going into the dedicated section (_Menu > Integration > Collect_).

The created elements are visible in the right panel and can be dragged and dropped in the central design zone to be assembled in the desired order.

By clicking on 'Next', you will access the layout design step where you can select a vertical or horizontal layout, specify footer behaviour and buttons, and even select a theme element from your models library to apply a specific look'n'feel to the form.

The 'Next' step will give you access to **Consent Context** data, allowing you to test your layout for any end-user (_real consent records and receipts will be generated and stored_). Example parameters:
- **Customer ID**: testuser
- **Validity**: 6 months
- **Confirmation Method**: None

<i class="fa fa-info-circle"></i> For specific documentation about Consent Context, please read the [dedicated guide]({% link _docs/201-consent-context-doc.md %}).
{: .notice--info}

Now, you can click on 'Get API Call UR' to reach an HTML version of the form for the provided end-user and follow the consent collection workflow according to the configured design.

### Export the generated context

By clicking on the 'Get API Call URL' button, you have generated a Consent Transaction which holds all the relevant information for the specified end-user. A full JSON representation of the Consent Context has been provided to the API and stored in a unique transaction accessible with its ID. A token has also been generated, allowing to send the generated URL by email for example.

This operation can also be done by making an API call with a specific Consent Context JSON. If you are authenticated as admin or operator, you can create transactions for end-users, but as a simple user, you can ony generate transactions for yourself.

The generated context JSON can then serve as a basis for integration in existing target applications. Some parts of that context can be dynamic, depending on the integration needs. Here is a minimal version of a Consent Context:

{% highlight json %}
{
  "subject":"testuser",
  "layoutData":{
    "type":"layout",
    "elements":["processing.001"],
    "orientation":"VERTICAL",
    "info":"information.001"
  }
}
{% endhighlight %}


## Integrate a simple consent collection scenario with cURL

### Authenticate test user

Use the testuser credentials in cURL over the identity provider to retrieve an access token allowing authenticated calls on the API:

{% highlight bash %}
RESPONSE=`curl -v -d "client_id=cmclient" \
                  -d "username=usertest" \
                  -d "password=test" \
                  -d "grant_type=password" \
                  http://localhost:4285/auth/realms/RightConsents/protocol/openid-connect/token`
ACCESS_TOKEN=`echo ${RESPONSE} | jq -r '.access_token'`
REFRESH_TOKEN=`echo ${RESPONSE} | jq -r '.refresh_token'`
{% endhighlight %}

The refresh token can be used later to avoid reusing the password:

{% highlight bash %}
RESPONSE=`curl -v -d "client_id=cmclient" \
                  -d "refresh_token=${REFRESH_TOKEN}" \
                  -d "grant_type=refresh_token" \
                  http://localhost:4285/auth/realms/RightConsents/protocol/openid-connect/token`
ACCESS_TOKEN=`echo ${RESPONSE} | jq -r '.access_token'`
REFRESH_TOKEN=`echo ${RESPONSE} | jq -r '.refresh_token'`
{% endhighlight %}

<i class="fa fa-info-circle"></i> You can also create a new user directly from the login screen of the GUI (at [http://localhost:4286](http://localhost:4286)) or in the identity provider admin console (at [http://localhost:4285/auth/admin](http://localhost:4285/auth/admin), credentials: admin/admin)
{: .notice--info}

The access token has a short period of validity and you may need to renew it while following the guide, in that case, simply replay these requests when needed.

### Create a consent transaction

Using the generated Consent Context, call the API to start a consent transaction:

{% highlight bash %}
TXID=`curl -v --header "Content-Type: application/json" \
              --header "Authorization: Bearer ${ACCESS_TOKEN}" \
              --request POST \
              --data '{"subject":"usertest","layoutData":{"type":"layout","elements":["processing.001"],"orientation":"VERTICAL","info":"information.001"}}' \
              http://localhost:4287/consents`
echo ${TXID}
{% endhighlight %}

This results in a new transaction being created. The response contains the unique transaction ID in its body but also a complete link to the created transaction in the Location header.

<i class="fa fa-info-circle"></i> If you wish not to use the same identity provider for your users as for the consent API, you will have to use a proxy (server side) to ensure the consent API authentication process (as admin or operator) and to generate transactions for the end-users without its own authentication. More information about authentication solutions are described in the [dedicated guide]({% link _docs/104-authentication-guide.md %}).
{: .notice--info}

### Get the transaction

The transaction API supports 2 mimetypes: HTML and JSON. In HTML, the client is supposed to be a browser and sending a GET call to the transaction resource will result in a redirection to the next action with human input needed for that transaction (submit consent, confirm consent, show receipt, restart a new transaction).

{% highlight bash %}
TX_HTML=`curl -v --header "Authorization: Bearer ${ACCESS_TOKEN}" \
                 --header "Accept: text/html" \
                 http://localhost:4287/consents/${TXID}`
echo ${TX_HTML}
{% endhighlight %}

In JSON, only a representation of the transaction is sent, including the link to the next action.

{% highlight bash %}
TX_JSON=`curl -v --header "Authorization: Bearer ${ACCESS_TOKEN}" \
                 --header "Accept: application/json" \
                 http://localhost:4287/consents/${TXID}`
echo ${TX_JSON}
FORM_URL=`echo ${TX_JSON} | jq -r '.task'`
echo ${FORM_URL}
{% endhighlight %}

In both cases, an authentication token is included to avoid using the OIDC Bearer token for the transaction process, making it easier to integrate in a popup or an iFrame. The token can be attached to all actions as a query parameter (i.e. /submit?t=$token).

A short version of the transaction right after creation is:

{% highlight json %}
{
   "id":"P6f1JU6LjKoUwR5QBEYPgf",
   "subject":"usertest",
   "state":"CREATED",
   "token":"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJQNmYxSlU2TGpLb1V3UjVRQkVZUGdmIiwiZXhwIjoxNjYwOTMwMzMyfQ.0pGomVcjvGGWshhovRpCKjP6BVOt2K6-W6QXLCVlwsA",
   "task":"http://localhost:4287/consents/P6f1JU6LjKoUwR5QBEYPgf/submit",
   "breed":"http://localhost:4287/consents/P6f1JU6LjKoUwR5QBEYPgf/child"
}
{% endhighlight %}

### Get consent form and submit values

Once the transaction is in the CREATED state, the next step is consent submission. Calling the URL of the task field will produce the form needed for consent submission:

{% highlight bash %}
FORM_JSON=`curl -v --header "Authorization: Bearer ${ACCESS_TOKEN}" \
                   --header "Accept: application/json" \
                   ${FORM_URL}`
echo ${FORM_JSON}
{% endhighlight %}

Many pieces of information are included in the JSON representation of the form, mainly to display legal information to the end-user. The HTML version is fully operational without any supplementary interpretation, the most important parts are the serial numbers of the elements. Only a handful of information is needed to submit a consent:

{% highlight bash %}
FORM_INFO_KEY=`echo ${FORM_JSON} | jq -r '.info.entry.key'`
FORM_INFO_SERIAL=`echo ${FORM_JSON} | jq -r '.info.serial'`
FORM_PROC_KEY=`echo ${FORM_JSON} | jq -r '.elements[0].entry.key'`
FORM_PROC_SERIAL=`echo ${FORM_JSON} | jq -r '.elements[0].serial'`
FORM_VALUES="\"{'info':['element/information/${FORM_INFO_KEY}/${FORM_INFO_SERIAL}'],'element/processing/${FORM_PROC_KEY}/${FORM_PROC_SERIAL}':['accepted']}\""
SUBMIT_JSON=`curl -v --header "Content-Type: application/json" \
                     --header "Authorization: Bearer ${ACCESS_TOKEN}" \
                     --header "Accept: application/json" \
                     --request POST \
                     --data ${FORM_VALUES} \
                     ${FORM_URL}`
{% endhighlight %}
